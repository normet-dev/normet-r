% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nm_norm_decom.r
\name{nm_decompose}
\alias{nm_decompose}
\title{Decompose Time Series Influences}
\usage{
nm_decompose(
  method = "emission",
  df = NULL,
  model = NULL,
  value = "value",
  backend = "h2o",
  feature_names = NULL,
  split_method = "random",
  fraction = 0.75,
  model_config = NULL,
  n_samples = 300,
  seed = 7654321,
  importance_ascending = FALSE,
  n_cores = NULL,
  memory_save = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{method}{The decomposition method to use. One of `"emission"` or `"meteorology"`.}

\item{df}{Data frame containing the input data.}

\item{model}{Optional pre-trained model for decomposition. If `NULL`, a model will be trained.}

\item{value}{The target variable name as a string.}

\item{backend}{The modeling backend to use if a model needs to be trained (e.g., 'h2o').}

\item{feature_names}{The names of the features used for training and decomposition.}

\item{split_method}{Method for splitting data for model training (e.g., 'random').}

\item{fraction}{Proportion of data for training if a model is trained.}

\item{model_config}{A list of configuration parameters for model training.}

\item{n_samples}{Number of samples for the normalisation process underlying the decomposition.}

\item{seed}{A random seed for reproducibility.}

\item{importance_ascending}{Logical. If `TRUE`, sorts meteorological features by
ascending importance. (Used only when `method = "meteorology"`).}

\item{n_cores}{Number of CPU cores for parallel processing.}

\item{memory_save}{Logical flag for memory-efficient normalisation.}

\item{verbose}{Should the function print progress messages and logs?}
}
\value{
A data frame with the decomposed components.
}
\description{
`nm_decompose` is a high-level wrapper that performs time series decomposition,
separating a target variable (e.g., pollutant concentration) into components
driven by emissions/trends and meteorology.
}
\details{
This function supports two decomposition methods:
\itemize{
  \item \strong{`emission`}: This method isolates the influence of time-based features
    (long-term trend, seasonality, day-of-week, and hour-of-day patterns).
    The result is a breakdown of the "emissions-driven" or "human activity" signal.
  \item \strong{`meteorology`}: This method isolates the influence of individual
    meteorological features (e.g., temperature, wind speed) based on their
    model-derived importance. The result is a breakdown of the
    "meteorology-driven" signal.
}
If a pre-trained `model` is not provided, the function will first train one using
the provided `df`, `value`, `feature_names`, and other training-related arguments.
}
\examples{
\dontrun{
# Assuming 'my_data' is a dataframe with 'date', 'pollutant', 'temp', 'wind'
features <- c("temp", "wind", "date_unix", "day_julian", "weekday", "hour")

# Run emission decomposition
df_emi <- nm_decompose(
  method = "emission",
  df = my_data,
  value = "pollutant",
  feature_names = features,
  n_samples = 100 # Use fewer samples for a quick example
)
head(df_emi)

# Run meteorology decomposition
df_met <- nm_decompose(
  method = "meteorology",
  df = my_data,
  value = "pollutant",
  feature_names = features,
  n_samples = 100
)
head(df_met)
}
}
